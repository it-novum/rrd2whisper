package rrdpath

import (
	"sync/atomic"
	"context"
	"log"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// XMLDatasource is holding the datasource structure of the rrd xml file
type XMLDatasource struct {
	Name string `xml:"NAME"`
}

// XMLNagios is holding the structure of the rrd xml file
type XMLNagios struct {
	XMLName     string `xml:"NAGIOS"`
	Hostname    string `xml:"NAGIOS_HOSTNAME"`
	Servicename string `xml:"NAGIOS_SERVICEDESC"`
	RrdTxt      string `xml:"RRD>TXT"`
	TimeT       int64  `xml:"NAGIOS_TIMET"`
	Datasources []XMLDatasource `xml:"DATASOURCE"`
	RrdPath string
	OkPath string
}

func parseRrdXML(path string) (*XMLNagios, error) {
	xmldata, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("Could not read xml file: %s", err)
	}
	xmlstruct := new(XMLNagios)
	err = xml.Unmarshal(xmldata, xmlstruct)
	if err != nil {
		return nil, fmt.Errorf("Could not parse xml structure: %s", err)
	}

	xmlstruct.RrdPath = path[:len(path)-4] + ".rrd"
	xmlstruct.OkPath = path[:len(path)-4] + ".ok"

	return xmlstruct, nil
}

// RrdPath provides a way to walk a directory for rrd xml files generated by statusengine
type RrdPath struct {
	results chan *XMLNagios
	brokenXMLCount uint64
	err error
	ctx context.Context
}

// Results provides a channel with the parsed xml files
func (rrdPath *RrdPath) Results() <-chan *XMLNagios {
	return rrdPath.results
}

// BrokenXML returns the counter of broken xml files
func (rrdPath *RrdPath) BrokenXML() uint64 {
	return atomic.LoadUint64(&rrdPath.brokenXMLCount)
}

func (rrdPath *RrdPath) Error() error {
	return rrdPath.err
}

// Walk searches for xml files in path, parses them and pushes them into a channel
// You can get the results with Results()
// If an error occurs the Error() func returns it
func Walk(ctx context.Context, path string) *RrdPath {
	rrdPath := &RrdPath{
		results: make(chan *XMLNagios),
		brokenXMLCount: 0,
		ctx: ctx,
	}

	go func(rrdPath *RrdPath) {
		done := rrdPath.ctx.Done()
		err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error {
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".xml") {
				xmlNagios, err := parseRrdXML(path)
				if err != nil {
					atomic.AddUint64(&rrdPath.brokenXMLCount, 1)
					log.Printf("Could not read xml file: %s", err)
				} else {
					rrdPath.results <- xmlNagios
				}
			}
			select {
			case <-done:
				return rrdPath.ctx.Err()
			default:
				return nil
			}
		})
		rrdPath.err = err
		close(rrdPath.results)
	}(rrdPath)


	return rrdPath
}
