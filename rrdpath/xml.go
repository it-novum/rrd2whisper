package rrdpath

import (
	"github.com/it-novum/rrd2whisper/logging"
	"sync/atomic"
	"context"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// XMLDatasource is holding the datasource structure of the rrd xml file
type XMLDatasource struct {
	Name string `xml:"NAME"`
}

// XMLNagios is holding the structure of the rrd xml file
type XMLNagios struct {
	XMLName     string `xml:"NAGIOS"`
	RrdTxt      string `xml:"RRD>TXT"`
	TimeT       int64  `xml:"NAGIOS_TIMET"`
	Datasources []XMLDatasource `xml:"DATASOURCE"`
	Path string
}

func parseRrdXML(path string) (*XMLNagios, error) {
	xmldata, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("could not read xml file: %s", err)
	}
	xmlstruct := new(XMLNagios)
	err = xml.Unmarshal(xmldata, xmlstruct)
	if err != nil {
		return nil, err
	}

	xmlstruct.Path = path

	return xmlstruct, nil
}

// RrdPath provides a way to walk a directory for rrd xml files generated by statusengine
type RrdPath struct {
	results chan *XMLNagios
	brokenXMLCount uint64
	err error
	ctx context.Context
}

// Results provides a channel with the parsed xml files
func (rrdPath *RrdPath) Results() <-chan *XMLNagios {
	return rrdPath.results
}

// BrokenXML returns the counter of broken xml files
func (rrdPath *RrdPath) BrokenXML() uint64 {
	return atomic.LoadUint64(&rrdPath.brokenXMLCount)
}

func (rrdPath *RrdPath) Error() error {
	return rrdPath.err
}

// Walk searches for xml files in path, parses them and pushes them into a channel
// You can get the results with Results()
// If an error occurs the Error() func returns it
func Walk(ctx context.Context, path string) *RrdPath {
	rrdPath := &RrdPath{
		results: make(chan *XMLNagios),
		brokenXMLCount: 0,
		ctx: ctx,
	}

	go func(rrdPath *RrdPath) {
		done := rrdPath.ctx.Done()
		err := filepath.Walk(path, func(path string, info os.FileInfo, errin error) error {
			var (
			    err error
			    xmlNagios *XMLNagios
			)
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".xml") {
				xmlNagios, err = parseRrdXML(path)
				if err != nil {
					atomic.AddUint64(&rrdPath.brokenXMLCount, 1)
					logging.Log("Could not read xml file: %s", err)
				}
			}
			if xmlNagios != nil {
				select {
				case <-done:
					return rrdPath.ctx.Err()
				case rrdPath.results <- xmlNagios:
					return nil
				}
			} else {
				select {
				case <-done:
					return rrdPath.ctx.Err()
				default:
					return nil
				}
			}
		})
		rrdPath.err = err
		close(rrdPath.results)
	}(rrdPath)


	return rrdPath
}
